"""
Generate deterministic .npy input arrays from shape/type strings.

Example:
    python3 create_inputs.py 4xi8 6x2x3xf32 9xf16

Behavior:
- For each argument like "6x2x3xf32", parse shape=[6,2,3], dtype=f32
- Rank-0 (no shape) is rejected
- Supported element types: f16, f32, i8, i16, i32
- Values are generated by casting integers sampled uniformly from [L, H]
- Random numbers are deterministic across platforms & Python versions
- Outputs are saved as arg0.npy, arg1.npy, ... in the current directory
"""

import sys
import re
import numpy as np

# ---------------- Configuration ----------------
# Deterministic RNG: use PCG64 explicitly for cross-version/platform stability.
S = 123456789  # random seed
rng = np.random.Generator(np.random.PCG64(S))

# Integer range for sampling (inclusive)
L = -7
H = 7
# ------------------------------------------------

SUPPORTED_DTYPES = {"f16", "f32", "i8", "i16", "i32"}


def parse_spec(spec: str):
    """
    Parse a spec of the form "<d0>x<d1>x...x<dtype>" where each d? is a positive int.
    Returns (shape_list, dtype_token).
    Raises ValueError on malformed input or rank-0 shape.
    """
    parts = spec.split("x")
    if len(parts) < 2:
        raise ValueError(
            f"Invalid spec '{spec}': expected '<shape>x<dtype>' (rank-0 not allowed)."
        )
    dtype_token = parts[-1].lower()
    dims_strs = parts[:-1]
    if dtype_token not in SUPPORTED_DTYPES:
        raise ValueError(
            f"Unsupported element type '{dtype_token}' in '{spec}'. "
            f"Supported: {sorted(SUPPORTED_DTYPES)}"
        )
    try:
        dims = [int(d) for d in dims_strs]
    except ValueError:
        raise ValueError(f"Invalid shape in '{spec}': all dimensions must be integers.")
    if any(d <= 0 for d in dims):
        raise ValueError(f"Invalid shape in '{spec}': all dimensions must be positive.")
    return dims, dtype_token


def dtype_from_token(token: str):
    """
    Map token to numpy dtype.
    """
    if token == "f16":
        return np.float16
    if token == "f32":
        return np.float32
    if token == "i8":
        return np.int8
    if token == "i16":
        return np.int16
    if token == "i32":
        return np.int32
    # Should not reach here due to earlier validation
    raise ValueError(f"Internal error: unhandled dtype token '{token}'")


def make_array(shape, dtype_token):
    """
    Create an array with given shape and dtype_token by sampling integers in [L, H]
    and casting to the requested dtype.
    """
    # Sample as 32-bit integers to be safe, then cast.
    ints = rng.integers(L, H + 1, size=shape, dtype=np.int32)
    dt = dtype_from_token(dtype_token)
    return ints.astype(dt, copy=False)


def main(argv):
    if len(argv) < 2:
        print("Usage: python3 create_inputs.py <shapextype> [<shapextype> ...]")
        print("  Example: python3 create_inputs.py 4xi8 6x2x3xf32 9xf16")
        sys.exit(1)

    specs = argv[1:]
    for idx, spec in enumerate(specs):
        try:
            shape, dtype_token = parse_spec(spec)
            arr = make_array(shape, dtype_token)
            out_name = f"arg{idx}.npy"
            np.save(out_name, arr)
            print(
                f"Created {out_name}: shape={tuple(shape)} dtype={arr.dtype} "
                f"from ints in [{L}, {H}] (seed={S})"
            )
        except Exception as e:
            print(f"Error processing '{spec}': {e}", file=sys.stderr)
            sys.exit(2)


if __name__ == "__main__":
    main(sys.argv)
